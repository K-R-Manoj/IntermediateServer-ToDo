let createError,body,isJsonString,authService,sign,CONFIG,eF,request200;_6ed‍.x([["preAuthenticate",()=>preAuthenticate],["verifyAuthentication",()=>verifyAuthentication]]);_6ed‍.w("http-errors",[["default",["createError"],function(v){createError=v}]]);_6ed‍.w("express-validator",[["body",["body"],function(v){body=v}]]);_6ed‍.w("../utils",[["isJsonString",["isJsonString"],function(v){isJsonString=v}],["errorFirst",["eF"],function(v){eF=v}]]);_6ed‍.w("../services/auth",[["default",["authService"],function(v){authService=v}]]);_6ed‍.w("jsonwebtoken",[["sign",["sign"],function(v){sign=v}]]);_6ed‍.w("../config",[["default",["CONFIG"],function(v){CONFIG=v}]]);_6ed‍.w("../request",[["request200",["request200"],function(v){request200=v}]]);








       const preAuthenticate = [
    body('code').notEmpty().withMessage('code is required').bail().isString().withMessage('code must be a string'),
];

const extractCustomAttributes = (userDetails) => {  
    userDetails = userDetails.body
    const userMetadata = userDetails['custom:Location']
    return {
      userMetadata,
      loginName: userDetails.email,
    };
};

const unAuthError = (error) => {
    if (isJsonString(error.message)) {
      const parsedErrorMessage = JSON.parse(error.message || '{}');
      const { data: { error: message = '' } = {} } = parsedErrorMessage;
      return createError(401, message, { expose: false });
    }
    return createError(401, error, { expose: false });
};


       const verifyAuthentication = async (req, res, next) => {
    const { code } = req.body;
    _6ed‍.g.console.log(code,"....code" );
    // STEP1: Exchange auth code for access token
    const accessTokenOptions = await authService.getAccessToken({
      code,
    });

    _6ed‍.g.console.log(accessTokenOptions,"......accessTokenOptions");

    const [tokenError, tokenDetails] = await eF(request200(accessTokenOptions, req, res));
    _6ed‍.g.console.log(tokenDetails,"....tokenDetails");
    _6ed‍.g.console.log(tokenError,"......TokenError");
    if (tokenError) {
      return next(unAuthError(tokenError));
    }
  
    // STEP2: Get user details using above access token
    const { access_token: accessToken, token_type: tokenType } = tokenDetails;
    _6ed‍.g.console.log(accessToken,".....accessToken");
    _6ed‍.g.console.log(tokenType,"....tokenType");
    const userDetailsOptions = await authService.getUserDetails({
      accessToken,
      tokenType,
    });
    _6ed‍.g.console.log(userDetailsOptions,".....UserDetailsOptions");
    const [errorUserDetails, userDetails] = await eF(request200(userDetailsOptions, req, res));
    _6ed‍.g.console.log(errorUserDetails,"......errorUserDetails");
    _6ed‍.g.console.log(userDetails,".....userDetails");
    if (errorUserDetails) {
      return next(unAuthError(errorUserDetails));
    }

    // STEP3: send the auth result
    const {userMetadata, loginName} = extractCustomAttributes(userDetails);
    _6ed‍.g.console.log(userMetadata,".......userMetadata");
    _6ed‍.g.console.log(loginName,".......loginName");
    const date = Date.now();
    const jwt = sign(
      {
        local: {
          userDetails,
          userMetadata,
          loginName,
          date,
        },
      },
      CONFIG.JWT_SECRET_PASS,
      { expiresIn: CONFIG.JWT_EXPIRY_TIME_IN_SEC }
    );
  
    return res.status(200).send({
      cognitoAccessToken: accessToken,
      userDetails,
      token: jwt,
      tokenExpiresAt: date + CONFIG.JWT_EXPIRY_TIME_IN_SEC * 1000,
    });
  };